#!/bin/sh

# Configuration file for the chef-client service, generated by template

CONFIG=<%= node["chef_client"]["conf_dir"] %>/client.rb
PIDFILE=<%= node["chef_client"]["run_path"] %>/client.pid
LOGFILE=<%= node["chef_client"]["log_dir"] %>/client.log
# Sleep interval between runs.
# This value is in seconds.
INTERVAL=<%= node["chef_client"]["interval"] %>
# Maximum amount of random delay before starting a run. Prevents every client
# from contacting the server at the exact same time.
# This value is in seconds.
SPLAY=<%= node["chef_client"]["splay"] %>
# Any additional chef-client options.
OPTIONS="<%= node["chef_client"]["daemon_options"].join(' ') %>"

. /etc/rc.subr

name="chef-client"

exec="<%= @client_bin %>"
prog=$name
rcvar=chef_client_enable
start_cmd="chef_client_start"
stop_cmd="chef_client_stop"
restart_cmd="chef_client_restart"
status_cmd="chef_client_status"

# Make sure settings are not empty
config=${CONFIG-/etc/chef/client.rb}
pidfile=${PIDFILE-/var/run/chef/client.pid}
logfile=${LOGFILE-/var/log/chef/client.log}
interval=${INTERVAL-1800}
splay=${SPLAY-20}
options=${OPTIONS-}

# NOTE: No array support in posix bourne shell
cmdline="$exec -d -c $config -L $logfile -P $pidfile -i $interval -s $splay $options"

load_rc_config $name

# Default to yes but configurable thru /etc/rc.conf manually
: ${chef_client_enable:=YES}

# Private function to get chef-client process id, supports multiple processes
__chef_client_pids() {
    # merge spaces because ending options could be a space
    pattern=`echo ${cmdline}`
    pids=`pgrep -f "$pattern"`

    # merge newlines so output is better
    echo $pids
}

chef_client_start() {
    [ -x $exec ] || exit 5
    [ -f $config ] || exit 6
    echo -n "Starting $prog: "
    # chef-client itself will detect if an instance already running by pid
    nohup ${cmdline} < /dev/null > /dev/null 2>&1 &
    if [ $? = 0 ]; then
        echo "[OK]"
        return 0
    else
        echo "[FAILED]"
        return 1
    fi
}

chef_client_stop() {
    echo -n "Stopping $prog: "
    pids=`__chef_client_pids`

    if [ -n "$pids" ]; then
        # First, try SIGTERM, then SIGKILL
        kill $pids
        sleep 1
        kill -KILL $pids >/dev/null 2>&1
        sleep 0.1

        if kill -0 $pids 2>/dev/null; then
            echo "[FAILED]"
            return 1
        fi
    else
        echo "not running"
        rm -f $pidfile
        return 0
    fi

    rm -f $pidfile
    echo "[OK]"
    return 0
}

chef_client_restart() {
    chef_client_stop
    chef_client_start
}

chef_client_status() {
    pids=`__chef_client_pids`

    if [ -n "$pids" ]; then
        echo "${prog} (pid $pids) is running..."
        return 0
    else
        echo "${prog} is stopped"
        return 3
    fi
}

run_rc_command "$1"
